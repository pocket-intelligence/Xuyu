import { app, BrowserWindow, ipcMain } from 'electron';
import { ensureBrowserInstalled, localChromePath } from './browserDownloader';
import { initializeDatabase } from './database/initialize';
import { SearchResultService } from './services/SearchResultService';
import { ResearchResultService } from './services/ResearchResultService';
import { DeepResearchScraper } from './DeepResearchScraper';
import * as fs from 'fs';
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

const BROWSER_PATH = localChromePath();
let mainWindow: BrowserWindow | null = null;

const createWindow = (): void => {
  // Create the browser window.
  mainWindow = new BrowserWindow({
    height: 600,
    width: 800,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools.
  mainWindow.webContents.openDevTools();
};

// 处理开始研究请求
ipcMain.on("start-research", async (event, params: { query: string; maxResults?: number }) => {
  console.log("收到开始研究请求，参数:", params);

  try {
    // 发送进度更新
    mainWindow?.webContents.send("research-progress", "正在初始化研究环境...");

    // 1. 创建搜索结果记录
    const searchResultService = new SearchResultService();

    // 2. 执行搜索任务
    const scraper = new DeepResearchScraper({
      query: params.query,
      maxResults: params.maxResults || 3,
      headless: true
    });

    // 执行搜索
    const results = await scraper.run();

    // 3. 保存完整的搜索结果
    const searchData = {
      query: params.query,
      subQueries: [
        {
          q: params.query,
          searchs: results.map(result => ({
            url: result.url,
            title: result.title,
            abstract: result.snippet || '',
            image_save_path: result.imagePath
          }))
        }
      ]
    };

    const searchResult = await searchResultService.createCompleteSearchResult(searchData);

    // 发送结果
    event.reply("research-result", {
      success: true,
      message: "研究完成",
      data: {
        search_id: searchResult.id
      }
    });
  } catch (error: any) {
    console.error("研究失败:", error);
    event.reply("research-result", {
      success: false,
      message: "研究失败: " + error.message
    });
  }
});

// 处理生成报告请求
ipcMain.on("generate-report", async (event, params: { search_id: number; full_text: string }) => {
  console.log("收到生成报告请求，参数:", params);

  try {
    // 创建研究报告
    const researchResultService = new ResearchResultService();
    const researchResult = await researchResultService.createResearchResult({
      searchId: params.search_id,
      fullText: params.full_text
    });

    // 发送结果
    event.reply("generate-report-result", {
      success: true,
      message: "报告生成完成",
      data: {
        id: researchResult.id
      }
    });
  } catch (error: any) {
    console.error("报告生成失败:", error);
    event.reply("generate-report-result", {
      success: false,
      message: "报告生成失败: " + error.message
    });
  }
});

// 处理获取搜索结果请求
ipcMain.on("get-search-results", async (event, params: { page?: number, limit?: number } = {}) => {
  console.log("收到获取搜索结果请求，参数:", params);

  try {
    const searchResultService = new SearchResultService();

    // 默认分页参数
    const page = params.page || 1;
    const limit = params.limit || 20;

    const { searchResults, total } = await searchResultService.getSearchResultsPaginated(page, limit);

    // 发送结果
    event.reply("get-search-results-result", {
      success: true,
      message: "获取搜索结果成功",
      data: {
        searchResults,
        total,
        page,
        limit
      }
    });
  } catch (error: any) {
    console.error("获取搜索结果失败:", error);
    event.reply("get-search-results-result", {
      success: false,
      message: "获取搜索结果失败: " + error.message
    });
  }
});

// 处理获取研究报告请求
ipcMain.on("get-research-results", async (event, params: { page?: number, limit?: number } = {}) => {
  console.log("收到获取研究报告请求，参数:", params);

  try {
    const researchResultService = new ResearchResultService();

    // 默认分页参数
    const page = params.page || 1;
    const limit = params.limit || 20;

    const { researchResults, total } = await researchResultService.getResearchResultsPaginated(page, limit);

    // 发送结果
    event.reply("get-research-results-result", {
      success: true,
      message: "获取研究报告成功",
      data: {
        researchResults,
        total,
        page,
        limit
      }
    });
  } catch (error: any) {
    console.error("获取研究报告失败:", error);
    event.reply("get-research-results-result", {
      success: false,
      message: "获取研究报告失败: " + error.message
    });
  }
});

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.whenReady().then(async () => {
  // 初始化数据库
  const dbInitialized = await initializeDatabase();
  if (!dbInitialized) {
    console.error("数据库初始化失败");
  }

  // 如果浏览器已存在，直接加载主页
  if (fs.existsSync(BROWSER_PATH)) {
    console.log("浏览器已存在，直接加载主页");
    createWindow();
  } else {
    console.log("浏览器不存在，需要下载");
    // 浏览器不存在 → 加载主页
    createWindow();

    try {
      await ensureBrowserInstalled((percent: number) => {
        console.log(`下载进度: ${percent}%`);
      });

      console.log("浏览器下载完成");
    } catch (err: any) {
      console.error("下载失败:", err.message);
    }
  }
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.